/**
 * @fileoverview Tests for auto-generated REST API route definitions
 * Verifies that API routes are properly generated with correct handlers and schemas
 */

import { describe, it, expect, vi, beforeEach } from 'vitest';
import { IncomingMessage, ServerResponse } from 'node:http';
import { 
  autoGeneratedApiRoutes, 
  getApiRouteByPath, 
  getApiRoutePaths,
  createmoveFileHandler,
  createmoveFilesHandler,
  createvalidateOperationHandler,
  createtestAutoExposureHandler
} from './api-routes.js';
import { FileOperations } from '../core/file-operations.js';

// Mock the FileOperations class
vi.mock('../core/file-operations.js', () => ({
  FileOperations: vi.fn().mockImplementation(() => ({
    moveFile: vi.fn().mockResolvedValue({
      success: true,
      modifiedFiles: [],
      createdFiles: ['test.md'],
      deletedFiles: [],
      errors: [],
      warnings: [],
      changes: []
    }),
    moveFiles: vi.fn().mockResolvedValue({
      success: true,
      modifiedFiles: [],
      createdFiles: ['test1.md', 'test2.md'],
      deletedFiles: [],
      errors: [],
      warnings: [],
      changes: []
    }),
    validateOperation: vi.fn().mockResolvedValue({
      valid: true,
      brokenLinks: 0,
      errors: []
    })
  }))
}));

// Mock the testAutoExposure function
vi.mock('../index.js', () => ({
  testAutoExposure: vi.fn().mockResolvedValue({
    message: 'Echo: test',
    timestamp: '2024-01-01T00:00:00.000Z',
    success: true
  })
}));

describe('Auto-Generated API Routes', () => {
  describe('Route Registry', () => {
    it('should export array of API routes', () => {
      expect(autoGeneratedApiRoutes).toBeDefined();
      expect(Array.isArray(autoGeneratedApiRoutes)).toBe(true);
      expect(autoGeneratedApiRoutes.length).toBeGreaterThan(0);
    });

    it('should include all expected core routes', () => {
      const paths = getApiRoutePaths();
      
      expect(paths).toContain('/api/move-file');
      expect(paths).toContain('/api/move-files');
      expect(paths).toContain('/api/validate-operation');
      expect(paths).toContain('/api/test-auto-exposure');
    });

    it('should have exactly 4 routes', () => {
      expect(autoGeneratedApiRoutes).toHaveLength(4);
    });
  });

  describe('Route Structure Validation', () => {
    it('should have valid route structure for all routes', () => {
      autoGeneratedApiRoutes.forEach(route => {
        expect(route).toHaveProperty('path');
        expect(route).toHaveProperty('method');
        expect(route).toHaveProperty('handler');
        expect(route).toHaveProperty('description');
        expect(route).toHaveProperty('inputSchema');
        expect(route).toHaveProperty('outputSchema');
        
        expect(typeof route.path).toBe('string');
        expect(route.method).toBe('POST');
        expect(typeof route.handler).toBe('function');
        expect(typeof route.description).toBe('string');
        expect(typeof route.inputSchema).toBe('object');
        expect(typeof route.outputSchema).toBe('object');
      });
    });

    it('should have valid JSON Schema structure for schemas', () => {
      autoGeneratedApiRoutes.forEach(route => {
        const inputSchema = route.inputSchema as any;
        const outputSchema = route.outputSchema as any;
        
        // Input schema validation
        expect(inputSchema).toHaveProperty('type');
        expect(inputSchema.type).toBe('object');
        expect(inputSchema).toHaveProperty('properties');
        expect(inputSchema).toHaveProperty('required');
        expect(inputSchema).toHaveProperty('additionalProperties');
        expect(inputSchema.additionalProperties).toBe(false);
        
        // Output schema validation
        expect(outputSchema).toHaveProperty('type');
        expect(outputSchema.type).toBe('object');
        expect(outputSchema).toHaveProperty('properties');
        expect(outputSchema).toHaveProperty('required');
        expect(outputSchema).toHaveProperty('additionalProperties');
        expect(outputSchema.additionalProperties).toBe(false);
      });
    });
  });

  describe('Helper Functions', () => {
    describe('getApiRouteByPath', () => {
      it('should return correct route when path exists', () => {
        const route = getApiRouteByPath('/api/move-file');
        expect(route).toBeDefined();
        expect(route?.path).toBe('/api/move-file');
      });

      it('should return undefined when path does not exist', () => {
        const route = getApiRouteByPath('/api/nonexistent');
        expect(route).toBeUndefined();
      });

      it('should handle empty string', () => {
        const route = getApiRouteByPath('');
        expect(route).toBeUndefined();
      });
    });

    describe('getApiRoutePaths', () => {
      it('should return array of all route paths', () => {
        const paths = getApiRoutePaths();
        
        expect(Array.isArray(paths)).toBe(true);
        expect(paths).toHaveLength(4);
        expect(paths).toContain('/api/move-file');
        expect(paths).toContain('/api/move-files');
        expect(paths).toContain('/api/validate-operation');
        expect(paths).toContain('/api/test-auto-exposure');
      });

      it('should return paths in consistent order', () => {
        const paths1 = getApiRoutePaths();
        const paths2 = getApiRoutePaths();
        
        expect(paths1).toEqual(paths2);
      });
    });
  });

  describe('Route Handlers', () => {
    let mockReq: Partial<IncomingMessage>;
    let mockRes: Partial<ServerResponse>;
    let mockFileOps: FileOperations;

    beforeEach(() => {
      mockReq = {
        on: vi.fn((event, callback) => {
          if (event === 'data') {
            callback('{"input": "test"}');
          } else if (event === 'end') {
            callback();
          }
        })
      };

      mockRes = {
        writeHead: vi.fn(),
        end: vi.fn()
      };

      mockFileOps = new FileOperations();
    });

    describe('createtestAutoExposureHandler', () => {
      it('should handle valid request correctly', async () => {
        mockReq.on = vi.fn((event, callback) => {
          if (event === 'data') {
            callback('{"input": "Hello World"}');
          } else if (event === 'end') {
            callback();
          }
        });

        await createtestAutoExposureHandler(
          mockReq as IncomingMessage,
          mockRes as ServerResponse,
          mockFileOps
        );

        expect(mockRes.writeHead).toHaveBeenCalledWith(200, { 'Content-Type': 'application/json' });
        expect(mockRes.end).toHaveBeenCalled();
      });

      it('should handle validation errors', async () => {
        mockReq.on = vi.fn((event, callback) => {
          if (event === 'data') {
            callback('{"invalid": "data"}');
          } else if (event === 'end') {
            callback();
          }
        });

        await createtestAutoExposureHandler(
          mockReq as IncomingMessage,
          mockRes as ServerResponse,
          mockFileOps
        );

        expect(mockRes.writeHead).toHaveBeenCalledWith(400, { 'Content-Type': 'application/json' });
      });

      it('should handle invalid JSON', async () => {
        mockReq.on = vi.fn((event, callback) => {
          if (event === 'data') {
            callback('invalid json');
          } else if (event === 'end') {
            callback();
          } else if (event === 'error') {
            callback(new Error('Invalid JSON'));
          }
        });

        await createtestAutoExposureHandler(
          mockReq as IncomingMessage,
          mockRes as ServerResponse,
          mockFileOps
        );

        expect(mockRes.writeHead).toHaveBeenCalledWith(500, { 'Content-Type': 'application/json' });
      });
    });

    describe('createmoveFileHandler', () => {
      it('should handle valid move file request', async () => {
        mockReq.on = vi.fn((event, callback) => {
          if (event === 'data') {
            callback('{"sourcePath": "old.md", "destinationPath": "new.md", "options": {}}');
          } else if (event === 'end') {
            callback();
          }
        });

        await createmoveFileHandler(
          mockReq as IncomingMessage,
          mockRes as ServerResponse,
          mockFileOps
        );

        expect(mockRes.writeHead).toHaveBeenCalledWith(200, { 'Content-Type': 'application/json' });
        expect(mockFileOps.moveFile).toHaveBeenCalledWith('old.md', 'new.md', {});
      });

      it('should handle missing required parameters', async () => {
        mockReq.on = vi.fn((event, callback) => {
          if (event === 'data') {
            callback('{"sourcePath": "old.md"}');
          } else if (event === 'end') {
            callback();
          }
        });

        await createmoveFileHandler(
          mockReq as IncomingMessage,
          mockRes as ServerResponse,
          mockFileOps
        );

        expect(mockRes.writeHead).toHaveBeenCalledWith(400, { 'Content-Type': 'application/json' });
      });
    });
  });

  describe('Schema Compliance', () => {
    it('should have routes with unique paths', () => {
      const paths = autoGeneratedApiRoutes.map(route => route.path);
      const uniquePaths = new Set(paths);
      
      expect(uniquePaths.size).toBe(paths.length);
    });

    it('should have non-empty descriptions for all routes', () => {
      autoGeneratedApiRoutes.forEach(route => {
        expect(route.description.length).toBeGreaterThan(0);
        expect(route.description.trim()).toBe(route.description);
      });
    });

    it('should use kebab-case for route paths', () => {
      autoGeneratedApiRoutes.forEach(route => {
        expect(route.path).toMatch(/^\/api\/[a-z]+(-[a-z]+)*$/);
      });
    });

    it('should only use POST method', () => {
      autoGeneratedApiRoutes.forEach(route => {
        expect(route.method).toBe('POST');
      });
    });
  });
});