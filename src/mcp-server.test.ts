import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import type { CallToolRequest, ListToolsRequest } from '@modelcontextprotocol/sdk/types.js';

// Mock console.error to avoid output during tests
const mockConsoleError = vi.spyOn(console, 'error').mockImplementation(() => {});

// Mock the markmv index module
vi.mock('./index.js', () => ({
  createMarkMv: vi.fn(() => ({
    moveFile: vi.fn().mockResolvedValue({
      success: true,
      modifiedFiles: [],
      createdFiles: ['test.md'],
      deletedFiles: [],
      errors: [],
      warnings: [],
      changes: []
    }),
    moveFiles: vi.fn().mockResolvedValue({
      success: true,
      modifiedFiles: [],
      createdFiles: ['test1.md', 'test2.md'],
      deletedFiles: [],
      errors: [],
      warnings: [],
      changes: []
    }),
    validateOperation: vi.fn().mockResolvedValue({
      valid: true,
      brokenLinks: 0,
      errors: []
    })
  })),
  testAutoExposure: vi.fn().mockResolvedValue({
    message: 'Test response',
    timestamp: '2023-01-01T00:00:00.000Z',
    success: true
  })
}));

// Mock auto-generated MCP tools
vi.mock('./generated/mcp-tools.js', () => ({
  autoGeneratedMcpTools: [
    {
      name: 'move_file',
      description: 'Move a single markdown file and update all references',
      inputSchema: {
        type: 'object',
        properties: {
          sourcePath: { type: 'string' },
          destinationPath: { type: 'string' },
          options: { type: 'object' }
        },
        required: ['sourcePath', 'destinationPath']
      }
    },
    {
      name: 'move_files',
      description: 'Move multiple markdown files and update all references',
      inputSchema: {
        type: 'object',
        properties: {
          moves: { type: 'array' },
          options: { type: 'object' }
        },
        required: ['moves']
      }
    },
    {
      name: 'validate_operation',
      description: 'Validate the result of a previous operation for broken links',
      inputSchema: {
        type: 'object',
        properties: {
          result: { type: 'object' }
        },
        required: ['result']
      }
    },
    {
      name: 'test_auto_exposure',
      description: 'Test function to demonstrate auto-exposure pattern',
      inputSchema: {
        type: 'object',
        properties: {
          input: { type: 'string' }
        },
        required: ['input']
      }
    }
  ],
  getMcpToolNames: vi.fn(() => ['move_file', 'move_files', 'validate_operation', 'test_auto_exposure'])
}));

// Mock AJV validators
vi.mock('./generated/ajv-validators.js', () => ({
  validateInput: vi.fn().mockReturnValue({ valid: true, errors: [] })
}));

// Mock MCP SDK Server
const mockSetRequestHandler = vi.fn();
const mockConnect = vi.fn().mockResolvedValue(undefined);

vi.mock('@modelcontextprotocol/sdk/server/index.js', () => ({
  Server: vi.fn().mockImplementation(() => ({
    setRequestHandler: mockSetRequestHandler,
    connect: mockConnect
  }))
}));

// Mock StdioServerTransport
vi.mock('@modelcontextprotocol/sdk/server/stdio.js', () => ({
  StdioServerTransport: vi.fn().mockImplementation(() => ({}))
}));

// Import the functions to test after mocks are set up
import { createMcpServer, startMcpServer } from './mcp-server.js';

describe('MCP Server', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('Server Creation', () => {
    it('should create an MCP server with correct configuration', () => {
      const server = createMcpServer();
      
      expect(server).toBeDefined();
      expect(mockSetRequestHandler).toHaveBeenCalledTimes(2); // ListTools and CallTool handlers
    });

    it('should register request handlers', () => {
      createMcpServer();
      
      // Check that setRequestHandler was called for both list and call tools
      expect(mockSetRequestHandler).toHaveBeenCalledTimes(2);
    });
  });

  describe('Tool Listing', () => {
    it('should handle list tools request', async () => {
      createMcpServer();
      
      // Get the first handler (should be ListTools)
      const listToolsHandler = mockSetRequestHandler.mock.calls[0]?.[1];
      expect(listToolsHandler).toBeDefined();

      const request: ListToolsRequest = {
        method: 'tools/list',
        params: {}
      };

      const result = await listToolsHandler(request);
      
      expect(result).toEqual({
        tools: expect.arrayContaining([
          expect.objectContaining({
            name: 'move_file',
            description: 'Move a single markdown file and update all references'
          }),
          expect.objectContaining({
            name: 'move_files', 
            description: 'Move multiple markdown files and update all references'
          }),
          expect.objectContaining({
            name: 'validate_operation',
            description: 'Validate the result of a previous operation for broken links'
          }),
          expect.objectContaining({
            name: 'test_auto_exposure',
            description: 'Test function to demonstrate auto-exposure pattern'
          })
        ])
      });
    });
  });

  describe('Tool Execution', () => {
    let callToolHandler: any;

    beforeEach(() => {
      vi.clearAllMocks();
      createMcpServer();
      
      // Get the second handler (should be CallTool)
      callToolHandler = mockSetRequestHandler.mock.calls[1]?.[1];
    });

    it('should execute move_file tool successfully', async () => {
      const request: CallToolRequest = {
        method: 'tools/call',
        params: {
          name: 'move_file',
          arguments: {
            sourcePath: 'source.md',
            destinationPath: 'dest.md',
            options: { dryRun: true }
          }
        }
      };

      const result = await callToolHandler(request);
      
      expect(result.content).toEqual([
        {
          type: 'text',
          text: expect.stringContaining('"success": true')
        }
      ]);
      expect(result.isError).toBeUndefined();
    });

    it('should execute move_files tool successfully', async () => {
      const request: CallToolRequest = {
        method: 'tools/call',
        params: {
          name: 'move_files',
          arguments: {
            moves: [
              { source: 'file1.md', destination: 'dest1.md' },
              { source: 'file2.md', destination: 'dest2.md' }
            ],
            options: { dryRun: true }
          }
        }
      };

      const result = await callToolHandler(request);
      
      expect(result.content).toEqual([
        {
          type: 'text',
          text: expect.stringContaining('"success": true')
        }
      ]);
      expect(result.isError).toBeUndefined();
    });

    it('should execute validate_operation tool successfully', async () => {
      const request: CallToolRequest = {
        method: 'tools/call',
        params: {
          name: 'validate_operation',
          arguments: {
            result: {
              success: true,
              modifiedFiles: ['test.md'],
              createdFiles: [],
              deletedFiles: [],
              errors: [],
              warnings: [],
              changes: []
            }
          }
        }
      };

      const result = await callToolHandler(request);
      
      expect(result.content).toEqual([
        {
          type: 'text',
          text: expect.stringContaining('"valid": true')
        }
      ]);
      expect(result.isError).toBeUndefined();
    });

    it('should execute test_auto_exposure tool successfully', async () => {
      const request: CallToolRequest = {
        method: 'tools/call',
        params: {
          name: 'test_auto_exposure',
          arguments: {
            input: 'test message'
          }
        }
      };

      const result = await callToolHandler(request);
      
      expect(result.content).toEqual([
        {
          type: 'text',
          text: expect.stringContaining('"success": true')
        }
      ]);
      expect(result.isError).toBeUndefined();
    });

    it('should handle unknown tool errors', async () => {
      const request: CallToolRequest = {
        method: 'tools/call',
        params: {
          name: 'unknown_tool',
          arguments: {}
        }
      };

      const result = await callToolHandler(request);
      
      expect(result.content).toEqual([
        {
          type: 'text',
          text: expect.stringContaining('Unknown tool: unknown_tool')
        }
      ]);
      expect(result.isError).toBe(true);
    });

    it('should handle invalid arguments for move_file', async () => {
      const request: CallToolRequest = {
        method: 'tools/call',
        params: {
          name: 'move_file',
          arguments: {
            sourcePath: 123, // invalid type
            destinationPath: 'dest.md'
          }
        }
      };

      const result = await callToolHandler(request);
      
      expect(result.content).toEqual([
        {
          type: 'text',
          text: expect.stringContaining('Invalid parameters for moveFile')
        }
      ]);
      expect(result.isError).toBe(true);
    });

    it('should handle invalid arguments for move_files', async () => {
      const request: CallToolRequest = {
        method: 'tools/call',
        params: {
          name: 'move_files',
          arguments: {
            moves: 'not an array' // invalid type
          }
        }
      };

      const result = await callToolHandler(request);
      
      expect(result.content).toEqual([
        {
          type: 'text',
          text: expect.stringContaining('Invalid parameters for moveFiles')
        }
      ]);
      expect(result.isError).toBe(true);
    });

    it('should handle invalid arguments for validate_operation', async () => {
      const request: CallToolRequest = {
        method: 'tools/call',
        params: {
          name: 'validate_operation',
          arguments: {
            result: 'not an object' // invalid type
          }
        }
      };

      const result = await callToolHandler(request);
      
      expect(result.content).toEqual([
        {
          type: 'text',
          text: expect.stringContaining('Invalid OperationResult structure')
        }
      ]);
      expect(result.isError).toBe(true);
    });

    it('should handle invalid arguments for test_auto_exposure', async () => {
      const request: CallToolRequest = {
        method: 'tools/call',
        params: {
          name: 'test_auto_exposure',
          arguments: {
            input: 123 // invalid type
          }
        }
      };

      const result = await callToolHandler(request);
      
      expect(result.content).toEqual([
        {
          type: 'text',
          text: expect.stringContaining('Invalid parameters for testAutoExposure')
        }
      ]);
      expect(result.isError).toBe(true);
    });

    it('should handle non-object arguments', async () => {
      const request: CallToolRequest = {
        method: 'tools/call',
        params: {
          name: 'move_file',
          arguments: 'not an object'
        }
      };

      const result = await callToolHandler(request);
      
      expect(result.content).toEqual([
        {
          type: 'text',
          text: expect.stringContaining('Invalid arguments object')
        }
      ]);
      expect(result.isError).toBe(true);
    });
  });

  describe('Server Startup', () => {
    it('should start MCP server successfully', async () => {
      await startMcpServer();
      
      expect(mockConnect).toHaveBeenCalledTimes(1);
      expect(mockConsoleError).toHaveBeenCalledWith('markmv MCP server started');
    });
  });

  describe('Utility Functions', () => {
    let callToolHandler: any;

    beforeEach(() => {
      vi.clearAllMocks();
      createMcpServer();
      callToolHandler = mockSetRequestHandler.mock.calls[1]?.[1];
    });

    it('should convert snake_case to camelCase', async () => {
      // Test the snakeToCamel function indirectly through tool execution
      const request: CallToolRequest = {
        method: 'tools/call',
        params: {
          name: 'move_file', // snake_case tool name
          arguments: {
            sourcePath: 'source.md',
            destinationPath: 'dest.md'
          }
        }
      };

      const result = await callToolHandler(request);
      
      // The handler should successfully convert move_file to moveFile and execute
      expect(result.isError).toBeUndefined();
    });

    it('should validate OperationResult structure', async () => {
      const validOperationResult = {
        success: true,
        modifiedFiles: ['test.md'],
        createdFiles: [],
        deletedFiles: [],
        errors: [],
        warnings: [],
        changes: []
      };

      const request: CallToolRequest = {
        method: 'tools/call',
        params: {
          name: 'validate_operation',
          arguments: {
            result: validOperationResult
          }
        }
      };

      const result = await callToolHandler(request);
      
      expect(result.isError).toBeUndefined();
      expect(result.content[0].text).toContain('"valid": true');
    });

    it('should reject invalid OperationResult structure', async () => {
      const invalidOperationResult = {
        success: true,
        // missing required arrays
      };

      const request: CallToolRequest = {
        method: 'tools/call',
        params: {
          name: 'validate_operation',
          arguments: {
            result: invalidOperationResult
          }
        }
      };

      const result = await callToolHandler(request);
      
      expect(result.isError).toBe(true);
      expect(result.content[0].text).toContain('Invalid OperationResult structure');
    });
  });
});