/**
 * @fileoverview Integration tests for the complete auto-exposure pattern workflow
 * Tests the end-to-end functionality from function definition to MCP/API exposure
 */

import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { mkdir, rm } from 'node:fs/promises';
import { join } from 'node:path';
import { tmpdir } from 'node:os';
import { testAutoExposure } from '../index.js';
import { autoGeneratedMcpTools, getMcpToolByName } from '../generated/mcp-tools.js';
import { autoGeneratedApiRoutes, getApiRouteByPath } from '../generated/api-routes.js';
import { validateInput, validateOutput } from '../generated/ajv-validators.js';

describe('Auto-Exposure Pattern Integration', () => {
  let testDir: string;

  beforeAll(async () => {
    testDir = join(tmpdir(), `markmv-integration-${Date.now()}`);
    await mkdir(testDir, { recursive: true });
  });

  afterAll(async () => {
    if (testDir) {
      await rm(testDir, { recursive: true, force: true });
    }
  });

  describe('End-to-End Workflow', () => {
    it('should expose testAutoExposure function through all channels', async () => {
      // 1. Verify function exists and works
      const result = await testAutoExposure('Integration Test');
      expect(result).toMatchObject({
        message: 'Echo: Integration Test',
        success: true
      });
      expect(typeof result.timestamp).toBe('string');

      // 2. Verify MCP tool is generated
      const mcpTool = getMcpToolByName('test_auto_exposure');
      expect(mcpTool).toBeDefined();
      expect(mcpTool?.name).toBe('test_auto_exposure');
      expect(mcpTool?.description).toContain('Test function to demonstrate auto-exposure');

      // 3. Verify API route is generated
      const apiRoute = getApiRouteByPath('/api/test-auto-exposure');
      expect(apiRoute).toBeDefined();
      expect(apiRoute?.path).toBe('/api/test-auto-exposure');
      expect(apiRoute?.method).toBe('POST');

      // 4. Verify validators work
      const validInput = { input: 'Integration Test' };
      const inputValidation = validateInput('testAutoExposure', validInput);
      expect(inputValidation.valid).toBe(true);

      const outputValidation = validateOutput('testAutoExposure', result);
      expect(outputValidation.valid).toBe(true);
    });

    it('should maintain consistency across all exposure channels', () => {
      // All channels should expose the same function with consistent metadata
      const mcpTool = getMcpToolByName('test_auto_exposure');
      const apiRoute = getApiRouteByPath('/api/test-auto-exposure');

      expect(mcpTool?.description).toBe(apiRoute?.description);
      
      // Input schemas should be consistent
      const mcpInputSchema = mcpTool?.inputSchema as any;
      const apiInputSchema = apiRoute?.inputSchema as any;
      
      expect(mcpInputSchema.properties.input.type).toBe(apiInputSchema.properties.input.type);
      expect(mcpInputSchema.properties.input.description).toBe(apiInputSchema.properties.input.description);
    });

    it('should handle the complete request/response cycle', async () => {
      // Test the full workflow from input validation to output validation
      const input = 'Full Cycle Test';
      const requestData = { input };

      // 1. Validate input
      const inputValidation = validateInput('testAutoExposure', requestData);
      expect(inputValidation.valid).toBe(true);

      // 2. Execute function
      const result = await testAutoExposure(input);

      // 3. Validate output
      const outputValidation = validateOutput('testAutoExposure', result);
      expect(outputValidation.valid).toBe(true);

      // 4. Verify result structure
      expect(result).toMatchObject({
        message: `Echo: ${input}`,
        success: true
      });
      expect(new Date(result.timestamp)).toBeInstanceOf(Date);
    });
  });

  describe('Schema Validation Integration', () => {
    it('should validate complex input scenarios', () => {
      const testCases = [
        { input: 'Simple string', shouldPass: true },
        { input: '', shouldPass: true },
        { input: 'üöÄ Unicode test! @#$%', shouldPass: true },
        { input: 'A'.repeat(10000), shouldPass: true },
        { input: 123, shouldPass: false },
        { input: null, shouldPass: false },
        { input: undefined, shouldPass: false },
        { notInput: 'wrong key', shouldPass: false },
        {}, // missing input
      ];

      testCases.forEach(({ input, shouldPass }, index) => {
        const data = input !== undefined ? { input } : (typeof input === 'object' && input !== null ? input : {});
        const result = validateInput('testAutoExposure', data);
        
        if (shouldPass) {
          expect(result.valid).toBe(true);
        } else {
          expect(result.valid).toBe(false);
          expect(result.errors.length).toBeGreaterThan(0);
        }
      });
    });

    it('should validate output schemas strictly', async () => {
      const validResult = await testAutoExposure('Schema Test');
      
      // Valid output should pass
      expect(validateOutput('testAutoExposure', validResult).valid).toBe(true);

      // Invalid outputs should fail
      const invalidOutputs = [
        { message: 'Echo: test', timestamp: validResult.timestamp }, // missing success
        { message: 'Echo: test', success: true }, // missing timestamp
        { timestamp: validResult.timestamp, success: true }, // missing message
        { message: 123, timestamp: validResult.timestamp, success: true }, // wrong type
        { message: 'Echo: test', timestamp: validResult.timestamp, success: 'true' }, // wrong type
      ];

      invalidOutputs.forEach((invalidOutput, index) => {
        const result = validateOutput('testAutoExposure', invalidOutput);
        expect(result.valid).toBe(false);
      });
    });
  });

  describe('Error Handling Integration', () => {
    it('should handle validation errors gracefully', () => {
      const invalidInputs = [
        null,
        undefined,
        'string instead of object',
        123,
        [],
        { wrongKey: 'value' },
        { input: 123 },
      ];

      invalidInputs.forEach(invalidInput => {
        const result = validateInput('testAutoExposure', invalidInput);
        expect(result.valid).toBe(false);
        expect(result.errors).toBeDefined();
        expect(Array.isArray(result.errors)).toBe(true);
        expect(result.errors.length).toBeGreaterThan(0);
      });
    });

    it('should provide meaningful error messages', () => {
      const result = validateInput('testAutoExposure', { input: 123 });
      
      expect(result.valid).toBe(false);
      expect(result.errors.length).toBeGreaterThan(0);
      expect(result.errors.some(error => 
        error.includes('type') || error.includes('string')
      )).toBe(true);
    });

    it('should handle unknown methods gracefully', () => {
      const result = validateInput('unknownMethod', { test: 'data' });
      
      expect(result.valid).toBe(false);
      expect(result.errors).toContain('Unknown method: unknownMethod');
    });
  });

  describe('Performance Integration', () => {
    it('should handle concurrent operations efficiently', async () => {
      const concurrentCount = 20;
      const testInput = 'Concurrent Test';

      const start = Date.now();
      
      const promises = Array(concurrentCount).fill(0).map(async (_, index) => {
        // Validate input
        const inputValidation = validateInput('testAutoExposure', { input: `${testInput} ${index}` });
        expect(inputValidation.valid).toBe(true);

        // Execute function
        const result = await testAutoExposure(`${testInput} ${index}`);

        // Validate output
        const outputValidation = validateOutput('testAutoExposure', result);
        expect(outputValidation.valid).toBe(true);

        return result;
      });

      const results = await Promise.all(promises);
      const duration = Date.now() - start;

      expect(results).toHaveLength(concurrentCount);
      expect(duration).toBeLessThan(2000); // Should complete within 2 seconds

      results.forEach((result, index) => {
        expect(result.message).toBe(`Echo: ${testInput} ${index}`);
        expect(result.success).toBe(true);
      });
    });

    it('should have efficient validation performance', () => {
      const validInput = { input: 'Performance Test' };
      const validOutput = {
        message: 'Echo: Performance Test',
        timestamp: new Date().toISOString(),
        success: true
      };

      const iterations = 1000;
      
      // Test input validation performance
      const inputStart = Date.now();
      for (let i = 0; i < iterations; i++) {
        validateInput('testAutoExposure', validInput);
      }
      const inputDuration = Date.now() - inputStart;

      // Test output validation performance
      const outputStart = Date.now();
      for (let i = 0; i < iterations; i++) {
        validateOutput('testAutoExposure', validOutput);
      }
      const outputDuration = Date.now() - outputStart;

      expect(inputDuration).toBeLessThan(200); // Should validate 1000 inputs in under 200ms
      expect(outputDuration).toBeLessThan(200); // Should validate 1000 outputs in under 200ms
    });
  });

  describe('Real-world Scenarios', () => {
    it('should handle realistic usage patterns', async () => {
      const realWorldInputs = [
        'User query about documentation',
        'Error: something went wrong',
        'DEBUG: trace information',
        'üîç Search for: "typescript patterns"',
        'Multi-line\ninput with\nspecial characters\n\t\r\n',
        JSON.stringify({ nested: 'object', with: 'quotes' }),
        '<script>alert("xss")</script>',
        'Very long input: ' + 'x'.repeat(5000),
      ];

      for (const input of realWorldInputs) {
        // Validate input
        const inputValidation = validateInput('testAutoExposure', { input });
        expect(inputValidation.valid).toBe(true);

        // Execute function
        const result = await testAutoExposure(input);

        // Validate output
        const outputValidation = validateOutput('testAutoExposure', result);
        expect(outputValidation.valid).toBe(true);

        // Verify correct behavior
        expect(result.message).toBe(`Echo: ${input}`);
        expect(result.success).toBe(true);
        expect(new Date(result.timestamp)).toBeInstanceOf(Date);
      }
    });

    it('should maintain type safety throughout the workflow', async () => {
      // This test ensures that TypeScript types are maintained
      // and no 'any' type coercion occurs

      const input: string = 'Type Safety Test';
      const requestData: { input: string } = { input };

      // Input validation should return proper types
      const inputResult: { valid: boolean; errors: string[] } = validateInput('testAutoExposure', requestData);
      expect(inputResult.valid).toBe(true);

      // Function should return proper types
      const functionResult: { message: string; timestamp: string; success: boolean } = await testAutoExposure(input);
      expect(functionResult.success).toBe(true);

      // Output validation should work with proper types
      const outputResult: { valid: boolean; errors: string[] } = validateOutput('testAutoExposure', functionResult);
      expect(outputResult.valid).toBe(true);

      // All type assertions should be satisfied
      const message: string = functionResult.message;
      const timestamp: string = functionResult.timestamp;
      const success: boolean = functionResult.success;

      expect(typeof message).toBe('string');
      expect(typeof timestamp).toBe('string');
      expect(typeof success).toBe('boolean');
    });
  });

  describe('Complete System Integration', () => {
    it('should demonstrate zero-config auto-exposure', async () => {
      // This test verifies that the testAutoExposure function
      // was automatically exposed without any manual configuration

      // 1. Function should be callable directly
      const directResult = await testAutoExposure('Zero Config Test');
      expect(directResult.success).toBe(true);

      // 2. Should be discoverable via MCP tools
      const mcpTools = autoGeneratedMcpTools;
      const testTool = mcpTools.find(tool => tool.name === 'test_auto_exposure');
      expect(testTool).toBeDefined();

      // 3. Should be discoverable via API routes
      const apiRoutes = autoGeneratedApiRoutes;
      const testRoute = apiRoutes.find(route => route.path === '/api/test-auto-exposure');
      expect(testRoute).toBeDefined();

      // 4. Should have working validation
      expect(validateInput('testAutoExposure', { input: 'test' }).valid).toBe(true);
      expect(validateOutput('testAutoExposure', directResult).valid).toBe(true);

      // 5. All without any manual configuration!
      expect(testTool?.description).toContain('auto-exposure');
      expect(testRoute?.description).toContain('auto-exposure');
    });
  });
});